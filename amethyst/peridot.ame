class Peridot_parser < Amethyst
  def call(name,*args)
    Call[{:name=>leterize(name),:ary=>args}]
  end
end
amethyst Peridot_parser{
	root = (body | defi | sequence)*:a .* {a}
	
	body = "class" "" name:name defi*:ary "end" @Klass
	
	defi = "def" "" defname:name {["obj self"]}:args  '(' ( ')' break | {args=args+[','] if args.size==1} .:[args])*  sequence:[ary] "end" @Def
	name = <a-zA-Z_>:s <a-zA-Z0-9_>*:{s+it*""}
	defname = (<^ \t\r\n()>)*:x {leterize(x*"")}
	
	atom = ""
       ( number:n         -> CCode["Int(#{n})"]
       | '"' until('"'):s -> CCode["Str(#{s.inspect})"]
       | '(|' expr:e "|)" -> Lambda[e]
			 | '(' expr:e ")" {e}
			 | 'if' "(" expr:expr ")" block:block {If[{:expr=>expr,:block=>block}]}
			 | '{' ('}' break | &'{' atom:{'{'+it[0]+'}'}:[s] | .:[s])* {CCode[s*""]}
			 | name:name '(' args:arg ')' -> call(name,"self",*arg)
 			 | name:name '(' ")"          -> call(name,"self")

		   | ~'end' name:name @Var
			 )

	args = listOf('expr',',')
	method = name
	
	expr_postfixed = atom:a ( 
                           ( '[' args:arg "]" "=" expr:arg2        -> call("[]=",a,*arg,arg2)
													 | '[' args:arg "]"                      -> call("[]",a,*arg)
													 | '.' name:name '(' args:arg ')'        -> call(name,a,*arg)
													 | '.' name:name ( '(' ")" )?            -> call(name,a)
                           ):a
	                        )* {a}
               

  expr = "" name:name '=' expr:expr @Assign
			 | expr_ar1

	expr_ar1 = expr_ar2:a (("+" expr_ar2
                         |"-" expr_ar2:{call('-',it)}):b {call('+',a,b)}:a)* {a}
	expr_ar2 = expr_ar3:a (("*"|"/"):op expr_ar3:b {call(op,a,b)}:a)* {a}
	expr_ar3 = expr_ar4:a (("**"):op    expr_ar4:b {call(op,a,b)}:a)* {a}
  expr_ar4 = "+" expr_ar4
           | "-" expr_ar4:{call('-',it)}
           | expr_postfixed  

	block = "{" sequence:s '}' {s}

	sequence = expr:[ary] ( newline expr:[ary])* @Seq
}
